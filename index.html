<!DOCTYPE html>
<html>
<head>
    <title>06.01 - Create a point cloud from an existing geometry</title>
    <script src="./libs/three.js"></script>
    <script src="./libs/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
    <style>
    body {
        margin: 0;
        overflow: hidden;
    }
    </style>
</head>
<script>

// global variables
var renderer;
var scene;
var camera;

var orbit;

var particles;

var showGeo,
    mainGeo,
    articlesGeo;

var maxLength;


var ps;

function init() {



    // create a scene, that will hold all our elements such as objects, cameras and lights.
    scene = new THREE.Scene();
    // scene.fog = new THREE.FogExp2( 0x000000, 0.0055);

    // create a camera, which defines where we're looking at.
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

    // create a render, sets the background color and the size
    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0x000000);
    renderer.setSize(window.innerWidth, window.innerHeight);

    // position and point the camera to the center of the scene
    camera.position.x = 0;
    camera.position.y = -50;
    camera.position.z = 100;
    camera.lookAt(scene.position);

    orbit = new THREE.OrbitControls(camera);

    loadModels(function() {
        var mainLength = mainGeo.vertices.length,
            articlesLength = articlesGeo.vertices.length;
        maxLength = Math.max(mainLength, articlesLength);
        showGeo = new THREE.Geometry();

        var count = 0;
        for (var i = 0; i < maxLength; i++) {
            if (count >= mainLength) {
                count = 0;
            }
            // showGeo.vertices.push(mainGeo.vertices[count++]);
            showGeo.vertices.push(new THREE.Vector3(mainGeo.vertices[count].x, mainGeo.vertices[count].y, mainGeo.vertices[count].z));
            count++;
        }
        var texture = new THREE.TextureLoader().load( "./assets/gradient.png" );
        var material = new THREE.PointsMaterial({
            size: 0.3,
            map: texture,
            transparent: true,
            alphaTest: 0.5,
            blending: THREE.AdditiveBlending,
        });
        var dot = new THREE.Points(showGeo, material);

        scene.add(dot);

        setTimeout(function() {
            // var count = 0;
            // for (var i = 0; i < maxLength; i++) {
            //     if (count >= articlesLength) {
            //         count = 0;
            //     }
            //     showGeo.vertices[i] = articlesGeo.vertices[i];
            // }
            // showGeo.verticesNeedUpdate = true;
            becomeArticles();
        }, 1000);
    });


    // add the output of the renderer to the html element
    document.body.appendChild(renderer.domElement);

    // call the render function
    render();
}

function becomeArticles() {
    var count = 0,
        tween,
        articlesLength = articlesGeo.vertices.length;
    for (var i = 0; i < maxLength; i++) {
        tween = showGeo.vertices[i].tween;
        (function(i) {
            // if (tween) {
            //     tween.stop()
            //         .to(articlesGeo.vertices[i], 500)
            //         .delay(Math.floor(1000 * Math.random()))
            //         .onUpdate(function() {
            //             showGeo.vertices[i].set(this.x, this.y, this.z);
            //             showGeo.verticesNeedUpdate = true;
            //         })
            //         .start();
            // } else {
                showGeo.vertices[i].tween = new TWEEN.Tween(showGeo.vertices[i])
                                                .to(articlesGeo.vertices[i], 500)
                                                .delay(Math.floor(1000 * Math.random()) + i * 0.05)
                                                .onUpdate(function() {
                                                    showGeo.vertices[i] = new THREE.Vector3(this.x, this.y, this.z);
                                                    // showGeo.vertices[i].set(this.x, this.y, this.z);
                                                    showGeo.verticesNeedUpdate = true;
                                                })
                                                .start();
            // }
        }(count))
        if (count >= articlesLength - 1) {
            count = 0;
        } else {
            count ++;
        }
        // showGeo.vertices[i] = articlesGeo.vertices[i];
    }
}

function loadModels(callback) {
    var counter = 0,
        NUM_OF_MODELS = 2;
    var loader = new THREE.JSONLoader();
    loader.load("./assets/blog1.json", function (geo, mat) {
        mainGeo = geo;
        if (++counter === NUM_OF_MODELS) {
            callback && callback();
        }
        // var material = new THREE.PointsMaterial({
        //     size: 2,
        //     sizeAttenuation: false
        // });
        // var dot = new THREE.Points(mainGeo, material);

        // scene.add(dot);
    });

    loader.load("./assets/storm-trooper.json", function (geo, mat) {
        articlesGeo = geo;
        if (++counter === NUM_OF_MODELS) {
            callback && callback();
        }
        // var material = new THREE.PointsMaterial({
        //     size: 2,
        //     sizeAttenuation: false
        // });
        // var dot = new THREE.Points(articlesGeo, material);
        //
        // scene.add(dot);
    });
}


var step = 0;
function render() {
    renderer.render(scene, camera);
    requestAnimationFrame(render);
    TWEEN.update();

    orbit.update();
}

// calls the init function when the window is done loading.
window.onload = init;

</script>
<body>
</body>
</html>
