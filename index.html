<!DOCTYPE html>
<html>
<head>
    <title>06.01 - Create a point cloud from an existing geometry</title>
    <script src="./libs/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
	<script src="./js/postprocessing/postprocessing.js"></script>
    <style>
    body {
        margin: 0;
        overflow: hidden;
    }
    </style>
</head>
<script>

// global variables
var renderer;
var scene;
var camera;

var composer,
    clock;

var orbit;

var particles;

var showGeo,
    mainGeo,
    articlesGeo;

var maxLength;

var mouseX = 0, mouseY = 0;
var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

function init() {



    // create a scene, that will hold all our elements such as objects, cameras and lights.
    scene = new THREE.Scene();
    // scene.fog = new THREE.FogExp2( 0x000000, 0.0055);

    // create a camera, which defines where we're looking at.
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

    // create a render, sets the background color and the size
    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0x000000);
    renderer.setSize(window.innerWidth, window.innerHeight);

    // position and point the camera to the center of the scene
    camera.position.x = 0;
    camera.position.y = -50;
    camera.position.z = 100;
    camera.lookAt(scene.position);

    // postprocessing

	// composer = new THREE.EffectComposer( renderer );
	// composer.addPass( new THREE.RenderPass( scene, camera ) );
    //
	// var effect = new THREE.ShaderPass( THREE.DotScreenShader );
	// effect.uniforms[ 'scale' ].value = 4;
	// composer.addPass( effect );
    //
	// var effect = new THREE.ShaderPass( THREE.RGBShiftShader );
	// effect.uniforms[ 'amount' ].value = 0;
	// effect.renderToScreen = true;
	// composer.addPass( effect );

    composer = new POSTPROCESSING.EffectComposer(renderer);
    composer.addPass(new POSTPROCESSING.RenderPass(scene, camera));

    var pass = new POSTPROCESSING.BloomPass({
        intensity: 2.0
    });
    pass.renderToScreen = true;
    composer.addPass(pass);

    // var pass = new POSTPROCESSING.BokehPass({
    //     focus: 0.5
    // });
    // pass.renderToScreen = true;
    // composer.addPass(pass);

    clock = new THREE.Clock();

    loadModels(function() {
        var mainLength = mainGeo.vertices.length,
            articlesLength = articlesGeo.vertices.length;
        maxLength = Math.max(mainLength, articlesLength);
        showGeo = new THREE.Geometry();

        // var count = 0;
        // for (var i = 0; i < maxLength; i++) {
        //     if (count >= mainLength) {
        //         count = 0;
        //     }
        //     // showGeo.vertices.push(mainGeo.vertices[count++]);
        //     showGeo.vertices.push(new THREE.Vector3(mainGeo.vertices[count].x, mainGeo.vertices[count].y, mainGeo.vertices[count].z));
        //     count++;
        // }
        for (var i = 0; i < maxLength; i++) {
            showGeo.vertices.push(new THREE.Vector3(Math.floor(200 * Math.random() - 100), Math.floor(200 * Math.random() - 100), Math.floor(200 * Math.random() - 100)));
            showGeo.vertices[i].tween = new TWEEN.Tween(showGeo.vertices[i]);
        }
        var texture = new THREE.TextureLoader().load( "./assets/gradient.png" );
        var material = new THREE.PointsMaterial({
            size: 1,
            map: texture,
            transparent: true,
            alphaTest: 0.5,
            blending: THREE.AdditiveBlending,
        });
        var dot = new THREE.Points(showGeo, material);

        scene.add(dot);

        setTimeout(function() {
            becomeMain();
        }, 1000);

        setTimeout(function() {
            becomeArticles();
        }, 5000);
    });


    // add the output of the renderer to the html element
    document.body.appendChild(renderer.domElement);

    document.addEventListener( 'mousemove', onDocumentMouseMove, false );

    window.addEventListener( 'resize', onWindowResize, false );

    // call the render function
    render();
}

function becomeArticles() {
    var count = 0,
        tween,
        articlesLength = articlesGeo.vertices.length;
    for (var i = 0; i < maxLength; i++) {
        tween = showGeo.vertices[i].tween;
        (function(i, count) {
            if (tween) {
                tween.stop()
                    .to(articlesGeo.vertices[count], 500)
                    .delay(Math.floor(1000 * Math.random()) + i * 0.05)
                    .onUpdate(function() {
                        // showGeo.vertices[i] = new THREE.Vector3(this.x, this.y, this.z);
                        showGeo.vertices[i].set(this.x, this.y, this.z);
                        showGeo.verticesNeedUpdate = true;
                    })
                    .start();
            } else {
                showGeo.vertices[i].tween = new TWEEN.Tween(showGeo.vertices[i])
                                                .to(articlesGeo.vertices[count], 500)
                                                .delay(Math.floor(1000 * Math.random()) + i * 0.05)
                                                .onUpdate(function() {
                                                    // showGeo.vertices[i] = new THREE.Vector3(this.x, this.y, this.z);
                                                    showGeo.vertices[i].set(this.x, this.y, this.z);
                                                    showGeo.verticesNeedUpdate = true;
                                                })
                                                .start();
            }
        }(i, count))
        if (count >= articlesLength - 1) {
            count = 0;
        } else {
            count ++;
        }
        // showGeo.vertices[i] = articlesGeo.vertices[i];
    }
}

function becomeMain() {
    var count = 0,
        tween,
        mainLength = mainGeo.vertices.length;
    for (var i = 0; i < maxLength; i++) {
        tween = showGeo.vertices[i].tween;
        (function(i, count) {
            if (tween) {
                tween.stop()
                    .to(mainGeo.vertices[count], 500)
                    .delay(Math.floor(1000 * Math.random()) + i * 0.05)
                    .onUpdate(function() {
                        // showGeo.vertices[i] = new THREE.Vector3(this.x, this.y, this.z);
                        showGeo.vertices[i].set(this.x, this.y, this.z);
                        showGeo.verticesNeedUpdate = true;
                    })
                    .start();
            } else {
                showGeo.vertices[i].tween = new TWEEN.Tween(showGeo.vertices[i])
                                                .to(mainGeo.vertices[count], 500)
                                                .delay(Math.floor(1000 * Math.random()) + i * 0.05)
                                                .onUpdate(function() {
                                                    // showGeo.vertices[i] = new THREE.Vector3(this.x, this.y, this.z);
                                                    showGeo.vertices[i].set(this.x, this.y, this.z);
                                                    showGeo.verticesNeedUpdate = true;
                                                })
                                                .start();
            }
        }(i, count))
        if (count >= mainLength - 1) {
            count = 0;
        } else {
            count ++;
        }
        // showGeo.vertices[i] = articlesGeo.vertices[i];
    }
}

function loadModels(callback) {
    var counter = 0,
        NUM_OF_MODELS = 2;
    var loader = new THREE.JSONLoader();
    loader.load("./assets/main.json", function (geo, mat) {
        mainGeo = geo;
        if (++counter === NUM_OF_MODELS) {
            callback && callback();
        }
        // var material = new THREE.PointsMaterial({
        //     size: 2,
        //     sizeAttenuation: false
        // });
        // var dot = new THREE.Points(mainGeo, material);

        // scene.add(dot);
    });

    loader.load("./assets/storm-trooper.json", function (geo, mat) {
        articlesGeo = geo;
        if (++counter === NUM_OF_MODELS) {
            callback && callback();
        }
        // var material = new THREE.PointsMaterial({
        //     size: 2,
        //     sizeAttenuation: false
        // });
        // var dot = new THREE.Points(articlesGeo, material);
        //
        // scene.add(dot);
    });
}

function onDocumentMouseMove( event ) {
	mouseX = ( event.clientX - windowHalfX ) / (1000 / camera.position.z) / 3;
	mouseY = ( event.clientY - windowHalfY ) / (1000 / camera.position.z) / 3;
}

function onWindowResize() {
	windowHalfX = window.innerWidth / 2;
	windowHalfY = window.innerHeight / 2;
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
}

var step = 0;
function render() {
    // renderer.render(scene, camera);
    requestAnimationFrame(render);
    TWEEN.update();

    camera.position.x += ( mouseX - camera.position.x ) * 0.05;
	camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
	camera.lookAt( scene.position );


    composer.render(clock.getDelta());
}

// calls the init function when the window is done loading.
window.onload = init;

</script>
<body>
</body>
</html>
